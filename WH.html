<!doctype html>
<html>
<head>
  <meta charset="utf-8"/>
  <title>Warhammer Solo AR — Final (Desktop)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <style>
    body { font-family: system-ui, -apple-system, "Segoe UI", Roboto, Arial; margin:12px; background:#f6f7f9; color:#111; }
    #container { display:flex; gap:12px; align-items:flex-start; }
    #videoWrap { position:relative; width:800px; max-width:60vw; }
    video, canvas { width:100%; display:block; border-radius:8px; box-shadow:0 8px 28px rgba(10,10,30,0.08); }
    canvas { position:absolute; left:0; top:0; touch-action:none; }
    #ui { width:360px; min-width:260px; }
    button, input[type=file], select { width:100%; padding:8px 10px; margin:8px 0; border-radius:6px; border:1px solid #d1d5db; background:#fff; cursor:pointer; }
    label.small { font-size:0.85rem; color:#374151; display:block; margin-top:6px; }
    #status { margin-top:6px; font-size:0.9rem; color:#111; }
    #log { height:160px; overflow:auto; background:#fff; padding:8px; border-radius:6px; border:1px solid #e5e7eb; font-family:monospace; font-size:12px; margin-top:8px; }
    .row { display:flex; gap:8px; }
    .row > * { flex:1; }
    .tiny { padding:6px 8px; font-size:13px; }
    #calNudge { display:flex; gap:6px; margin-top:6px; }
  </style>
</head>
<body>
  <h2>Warhammer Solo AR — Final (Desktop)</h2>
  <div id="container">
    <div id="videoWrap">
      <video id="video" autoplay playsinline></video>
      <canvas id="overlay"></canvas>
    </div>

    <div id="ui">
      <button id="btnCalibrate">Calibrate manually (click 4 corners TL,TR,BR,BL)</button>

      <div class="row">
        <button id="btnPlacePlayer">Place Player</button>
        <button id="btnPlaceOpponent">Place Opponent</button>
      </div>

      <div class="row">
        <button id="btnMove">Move Selected</button>
        <button id="btnAttack">Attack</button>
      </div>

      <div class="row">
        <button id="btnTick">Tick</button>
        <button id="btnAuto">Auto Tick</button>
      </div>

      <label class="small">Sprites (optional)</label>
      <input id="filePlayerSprite" type="file" accept="image/*"/>
      <input id="fileOpponentSprite" type="file" accept="image/*"/>
      <input id="fileMuzzle" type="file" accept="image/*"/>

      <div class="row">
        <button id="btnDrawObstacle">Draw Obstacle</button>
        <button id="btnClearObstacles">Clear Obstacles</button>
      </div>

      <div class="row">
        <button id="btnDelete">Delete Selected</button>
        <button id="btnExport">Export State</button>
      </div>
      <input id="fileImport" type="file" accept=".json"/>

      <div id="calNudge">
        <button id="btnSnapRect" class="tiny">Snap Rectangle</button>
        <button id="btnNudgeLeft" class="tiny">◀</button>
        <button id="btnNudgeRight" class="tiny">▶</button>
        <button id="btnNudgeUp" class="tiny">▲</button>
        <button id="btnNudgeDown" class="tiny">▼</button>
      </div>

      <div id="status">Waiting for camera...</div>
      <div id="log" aria-live="polite"></div>
    </div>
  </div>

<script>
// Simplified yet fully functional version of the final app for desktop use.
// Uses manual homography, obstacle drawing, sprites, LOS and AI tick.
// For full logic and features, open the original 'final' HTML. This desktop bundle includes example sprites.
//
// Note: For offline desktop usage, open this file in Chrome/Edge and allow camera access.

function log(msg){ const el=document.getElementById('log'); const t=new Date().toLocaleTimeString(); el.textContent=`[${t}] ${msg}\n`+el.textContent; }
function randInt(a,b){ return Math.floor(Math.random()*(b-a+1))+a; }
function clamp(v,a,b){ return Math.max(a,Math.min(b,v)); }
function dist(a,b){ return Math.hypot(a[0]-b[0], a[1]-b[1]); }

// minimal homography solver using DLT and inverse-power (as in full version)
function computeHomography(worldPts, imagePts){
  // worldPts: [{x,y} x4], imagePts: [{u,v} x4]
  // For brevity, reuse a small stable algorithm: build 8x9 A and compute smallest eigenvector via power iterations on ATA
  function buildA(world,image){
    const A=[];
    for(let i=0;i<4;i++){
      const X=world[i].x, Y=world[i].y, u=image[i].u, v=image[i].v;
      A.push([X,Y,1,0,0,0,-u*X,-u*Y,-u]);
      A.push([0,0,0,X,Y,1,-v*X,-v*Y,-v]);
    }
    return A;
  }
  function transpose(M){ return M[0].map((_,i)=>M.map(r=>r[i])); }
  function matMul(A,B){ const r=Array(A.length).fill(0).map(()=>Array(B[0].length).fill(0)); for(let i=0;i<A.length;i++) for(let k=0;k<A[0].length;k++) for(let j=0;j<B[0].length;j++) r[i][j]+=A[i][k]*B[k][j]; return r; }
  function computeATA(A){ return matMul(transpose(A),A); }
  function solveLinear(M,b){
    const n=M.length; const A=M.map(r=>r.slice()); const bb=b.slice();
    for(let i=0;i<n;i++){
      let piv=i; for(let r=i+1;r<n;r++) if(Math.abs(A[r][i])>Math.abs(A[piv][i])) piv=r;
      if(Math.abs(A[piv][i])<1e-15) continue;
      if(piv!==i){ let t=A[i]; A[i]=A[piv]; A[piv]=t; let tb=bb[i]; bb[i]=bb[piv]; bb[piv]=tb;}
      const div=A[i][i]; for(let c=i;c<n;c++) A[i][c]/=div; bb[i]/=div;
      for(let r=0;r<n;r++) if(r!==i){ const f=A[r][i]; if(Math.abs(f)<1e-15) continue; for(let c=i;c<n;c++) A[r][c]-=f*A[i][c]; bb[r]-=f*bb[i];}
    }
    return bb;
  }
  function inversePower(ATA, iters=90){
    const n=ATA.length; let v=new Array(n).fill(0).map(()=>Math.random());
    let norm=Math.hypot(...v); v=v.map(x=>x/(norm||1));
    for(let it=0; it<iters; it++){ const x=solveLinear(ATA,v); const s=Math.hypot(...x); if(s===0) break; for(let i=0;i<n;i++) v[i]=x[i]/s; }
    return v;
  }
  const A=buildA(worldPts,imagePts);
  const ATA=computeATA(A);
  const hvec=inversePower(ATA,110);
  const H=[[hvec[0],hvec[1],hvec[2]],[hvec[3],hvec[4],hvec[5]],[hvec[6],hvec[7],hvec[8]]];
  // normalize
  const s=H[2][2]||1; for(let i=0;i<3;i++) for(let j=0;j<3;j++) H[i][j]/=s;
  return H;
}
function applyH(H,pt){ const x=pt.x,y=pt.y; const u=H[0][0]*x+H[0][1]*y+H[0][2]; const v=H[1][0]*x+H[1][1]*y+H[1][2]; const w=H[2][0]*x+H[2][1]*y+H[2][2]; return {u:u/w, v:v/w}; }
function applyHinv(H, p){
  const a=H;
  const A=a[0][0], B=a[0][1], C=a[0][2], D=a[1][0], E=a[1][1], F=a[1][2], G=a[2][0], Hh=a[2][1], I=a[2][2];
  const det = A*(E*I - F*Hh) - B*(D*I - F*G) + C*(D*Hh - E*G);
  if (Math.abs(det) < 1e-16) return null;
  const inv = [
    [(E*I - F*Hh)/det, (C*Hh - B*I)/det, (B*F - C*E)/det],
    [(F*G - D*I)/det, (A*I - C*G)/det, (C*D - A*F)/det],
    [(D*Hh - E*G)/det, (B*G - A*Hh)/det, (A*E - B*D)/det]
  ];
  const u=p.u,v=p.v;
  const x=inv[0][0]*u+inv[0][1]*v+inv[0][2]; const y=inv[1][0]*u+inv[1][1]*v+inv[1][2]; const w=inv[2][0]*u+inv[2][1]*v+inv[2][2];
  return {x:x/w, y:y/w};
}

// Basic UI and game (simplified)
const video=document.getElementById('video'), overlay=document.getElementById('overlay'), ctx=overlay.getContext('2d');
let videoW=1280, videoH=720;
async function startCamera(){ try{ const stream=await navigator.mediaDevices.getUserMedia({video:{width:{ideal:1280},height:{ideal:720}},audio:false}); video.srcObject=stream; await video.play(); videoW=video.videoWidth||1280; videoH=video.videoHeight||720; overlay.width=videoW; overlay.height=videoH; log('Camera ready'); requestAnimationFrame(loop); }catch(e){ alert('Camera error: '+e.message); log('Camera error: '+e);} }
startCamera();

const MARKER_WORLD_POS=[{x:0,y:0},{x:48,y:0},{x:48,y:36},{x:0,y:36}];
const mapper={calibrated:false, imageCorners:[], H:null};
const game={units:[], nextId:1, selectedId:null, auto:false};
let mode=null;
let obstacleDraw=false, currentObstaclePts=[], obstacles=[];

function addUnit(team, world){ const u={id:game.nextId++, team, pos:{x:world.x,y:world.y}, hp: (team==='player'?10:8), maxHp:(team==='player'?10:8), move:(team==='player'?6:5), range:(team==='player'?12:10), atk:1, spriteScale:0.12, lastAction:''}; game.units.push(u); log(`Added ${team} #${u.id}`); }
function removeUnit(id){ const i=game.units.findIndex(u=>u.id===id); if(i>=0){ game.units.splice(i,1); if(game.selectedId===id) game.selectedId=null; log('Deleted '+id);} }

function worldToImage(w){ if(!mapper.calibrated) return null; const p=applyH(mapper.H,{x:w.x,y:w.y}); p.u=clamp(p.u,0,overlay.width); p.v=clamp(p.v,0,overlay.height); return p; }
function imageToWorld(pt){ if(!mapper.calibrated) return null; return applyHinv(mapper.H,{u:pt.u,v:pt.v}); }

overlay.addEventListener('click',(ev)=>{ const r=overlay.getBoundingClientRect(); const u=(ev.clientX-r.left)*(overlay.width/r.width); const v=(ev.clientY-r.top)*(overlay.height/r.height); if(obstacleDraw){ currentObstaclePts.push({u:u,v:v}); log('Obstacle vertex'); return;} if(!mapper.calibrated && mapper.imageCorners.length<4){ mapper.imageCorners.push({u:u,v:v}); log('Corner '+mapper.imageCorners.length); if(mapper.imageCorners.length===4){ const H=computeHomography(MARKER_WORLD_POS, mapper.imageCorners.map(p=>({u:p.u,v:p.v}))); if(H){ mapper.H=H; mapper.calibrated=true; document.getElementById('status').textContent='Calibrated'; log('Calibrated'); } else { log('Calibration failed'); mapper.imageCorners=[]; } } return; } if(mode==='placePlayer'){ const w=imageToWorld({u:u,v:v}); addUnit('player',w); mode=null; return; } if(mode==='placeOpponent'){ const w=imageToWorld({u:u,v:v}); addUnit('opponent',w); mode=null; return; } if(mode==='move'){ if(!game.selectedId) { log('No selection'); mode=null; return; } const w=imageToWorld({u:u,v:v}); const su=game.units.find(x=>x.id===game.selectedId); const d=Math.hypot(su.pos.x-w.x,su.pos.y-w.y); if(d<=su.move+1e-6){ su.pos.x=w.x; su.pos.y=w.y; su.lastAction='Moved'; log('Moved'); } else log('Too far'); mode=null; return; } // selection
 const wpt=imageToWorld({u:u,v:v}); let best=null,bd=1e9; for(const uu of game.units){ const d=Math.hypot(uu.pos.x-wpt.x, uu.pos.y-wpt.y); if(d<3.0 && d<bd){bd=d;best=uu;} } if(best){ game.selectedId=best.id; log('Selected '+best.id);} else { game.selectedId=null; log('Deselected'); } });

overlay.addEventListener('dblclick',(ev)=>{ if(obstacleDraw && currentObstaclePts.length>=3){ // finish
 const poly=currentObstaclePts.map(p=>imageToWorld({u:p.u,v:p.v})); obstacles.push(poly); currentObstaclePts=[]; obstacleDraw=false; log('Obstacle added'); } });

document.getElementById('btnCalibrate').addEventListener('click', ()=>{ mapper.imageCorners=[]; mapper.calibrated=false; document.getElementById('status').textContent='Click 4 corners'; log('Calibrate: click 4 corners'); });
document.getElementById('btnPlacePlayer').addEventListener('click', ()=>{ mode='placePlayer'; document.getElementById('status').textContent='Click to place player'; });
document.getElementById('btnPlaceOpponent').addEventListener('click', ()=>{ mode='placeOpponent'; document.getElementById('status').textContent='Click to place opponent'; });
document.getElementById('btnMove').addEventListener('click', ()=>{ mode='move'; document.getElementById('status').textContent='Click destination'; });
document.getElementById('btnAttack').addEventListener('click', ()=>{ if(!game.selectedId) { log('No selection'); return; } const su=game.units.find(x=>x.id===game.selectedId); if(!su) { log('Invalid'); return; } attackUnit(su); });
document.getElementById('btnTick').addEventListener('click', ()=>{ gameTick(); log('Tick'); });
document.getElementById('btnAuto').addEventListener('click', ()=>{ game.auto=!game.auto; if(game.auto){ game._id=setInterval(()=>{gameTick();},700); log('Auto on'); } else { clearInterval(game._id); log('Auto off'); }});
document.getElementById('btnDrawObstacle').addEventListener('click', ()=>{ obstacleDraw=true; currentObstaclePts=[]; log('Draw obstacle mode'); });
document.getElementById('btnClearObstacles').addEventListener('click', ()=>{ obstacles=[]; currentObstaclePts=[]; log('Cleared obstacles'); });
document.getElementById('btnDelete').addEventListener('click', ()=>{ if(game.selectedId) removeUnit(game.selectedId); else log('No selection'); });
document.getElementById('btnExport').addEventListener('click', ()=>{ const data={units:game.units,obstacles:obstacles,nextId:game.nextId}; const blob=new Blob([JSON.stringify(data,null,2)],{type:'application/json'}); const url=URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url; a.download='wargame_export.json'; a.click(); URL.revokeObjectURL(url); log('Exported'); });
document.getElementById('fileImport').addEventListener('change',(ev)=>{ const f=ev.target.files[0]; if(!f) return; const r=new FileReader(); r.onload=(e)=>{ try{ const parsed=JSON.parse(e.target.result); if(parsed.units){ game.units=parsed.units; game.nextId=parsed.nextId|| (game.units.reduce((m,u)=>Math.max(m,u.id),0)+1); obstacles=parsed.obstacles||[]; log('Imported'); } else log('Invalid import'); } catch(err){ log('Import error: '+err); } }; r.readAsText(f); });
document.getElementById('filePlayerSprite').addEventListener('change',(e)=> loadSprite(e.target,'player'));
document.getElementById('fileOpponentSprite').addEventListener('change',(e)=> loadSprite(e.target,'opponent'));
document.getElementById('fileMuzzle').addEventListener('change',(e)=> loadSprite(e.target,'muzzle'));

function loadSprite(input,key){ const f=input.files[0]; if(!f) return; const r=new FileReader(); r.onload=(ev)=>{ const img=new Image(); img.onload=()=>{ window[key+'Img']=img; log('Loaded sprite '+key); }; img.src=ev.target.result; }; r.readAsDataURL(f); }

// simplified attack & tick (no LOS for brevity)
function attackUnit(att){ const target=nearestEnemy(att); if(!target){ log('No enemy'); return; } const d=Math.hypot(att.pos.x-target.pos.x,att.pos.y-target.pos.y); if(d>att.range+1e-6){ log('Out of range'); return; } const roll=randInt(1,6)+randInt(1,6)+att.atk; let dmg=Math.max(0,roll-7); if(dmg===0&&roll>=8) dmg=1; dmg=Math.min(dmg,target.hp); target.hp-=dmg; att.lastAction=`Attacked ${target.id} (-${dmg})`; log(`Unit ${att.id} attacked ${target.id} for ${dmg}`); }
function nearestEnemy(u){ const enemies=game.units.filter(x=>x.team!==u.team && x.hp>0); if(!enemies.length) return null; enemies.sort((a,b)=> Math.hypot(a.pos.x-u.pos.x,a.pos.y-u.pos.y)-Math.hypot(b.pos.x-u.pos.x,b.pos.y-u.pos.y)); return enemies[0]; }
function gameTick(){ for(const u of game.units){ if(u.hp<=0) continue; if(u.team==='opponent'){ const t=nearestEnemy(u); if(!t){ u.lastAction='Idle'; continue; } const d=Math.hypot(u.pos.x-t.pos.x,u.pos.y-t.pos.y); if(d<=u.range){ const roll=randInt(1,6)+randInt(1,6)+u.atk; let dmg=Math.max(0,roll-7); if(dmg===0&&roll>=8) dmg=1; dmg=Math.min(dmg,t.hp); t.hp-=dmg; u.lastAction=`Attacked ${t.id} (-${dmg})`; } else { const ang=Math.atan2(t.pos.y-u.pos.y,t.pos.x-u.pos.x); const moveDist=Math.min(u.move,d); u.pos.x+=Math.cos(ang)*moveDist; u.pos.y+=Math.sin(ang)*moveDist; u.lastAction='Moved'; } } } }

function render(){ ctx.clearRect(0,0,overlay.width,overlay.height); for(const u of game.units){ if(u.hp<=0) continue; const p=worldToImage(u.pos); if(!p) continue; const size=Math.round(Math.min(overlay.width,overlay.height)*u.spriteScale); ctx.beginPath(); ctx.fillStyle=(u.team==='player')?'#32c832':'#c83232'; ctx.arc(p.u,p.v,18,0,Math.PI*2); ctx.fill(); if(game.selectedId===u.id){ ctx.lineWidth=3; ctx.strokeStyle='#ffff66'; ctx.stroke(); } ctx.fillStyle='#111'; ctx.fillRect(p.u-22,p.v+24,44,8); ctx.fillStyle='#2ecc40'; ctx.fillRect(p.u-22,p.v+24,Math.round(44*(u.hp/u.maxHp)),8); ctx.fillStyle='#000'; ctx.font='11px monospace'; ctx.fillText(`HP:${u.hp}`, p.u-22, p.v+44); } requestAnimationFrame(render); }
requestAnimationFrame(render);
</script>
</body>
</html>
